{"version":3,"sources":["../src/vad.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\r\n//\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport {\r\n  ExpFilter,\r\n  VADEventType,\r\n  VADStream as baseStream,\r\n  VAD as baseVAD,\r\n  log,\r\n  mergeFrames,\r\n} from '@livekit/agents';\r\nimport { AudioFrame, AudioResampler, AudioResamplerQuality } from '@livekit/rtc-node';\r\nimport type { InferenceSession } from 'onnxruntime-node';\r\nimport type { SampleRate } from './onnx_model.js';\r\nimport { OnnxModel, newInferenceSession } from './onnx_model.js';\r\n\r\nconst SLOW_INFERENCE_THRESHOLD = 200; // late by 200ms\r\n\r\nexport interface VADOptions {\r\n  /** Minimum duration of speech to start a new speech chunk */\r\n  minSpeechDuration: number;\r\n  /** At the end of each speech, wait this duration before ending the speech */\r\n  minSilenceDuration: number;\r\n  /** Duration of padding to add to the beginning of each speech chunk */\r\n  prefixPaddingDuration: number;\r\n  /** Maximum duration of speech to keep in the buffer */\r\n  maxBufferedSpeech: number;\r\n  /** Maximum duration of speech to keep in the buffer*/\r\n  activationThreshold: number;\r\n  /** Sample rate for the inference (only 8KHz and 16KHz are supported) */\r\n  sampleRate: SampleRate;\r\n  /** Force the use of CPU for inference */\r\n  forceCPU: boolean;\r\n}\r\n\r\nconst defaultVADOptions: VADOptions = {\r\n  minSpeechDuration: 50,\r\n  minSilenceDuration: 250,\r\n  prefixPaddingDuration: 500,\r\n  maxBufferedSpeech: 60000,\r\n  activationThreshold: 0.5,\r\n  sampleRate: 16000,\r\n  forceCPU: true,\r\n};\r\n\r\nexport class VAD extends baseVAD {\r\n  #session: InferenceSession;\r\n  #opts: VADOptions;\r\n  #streams: VADStream[];\r\n  label = 'silero.VAD';\r\n\r\n  constructor(session: InferenceSession, opts: VADOptions) {\r\n    super({ updateInterval: 32 });\r\n    this.#session = session;\r\n    this.#opts = opts;\r\n    this.#streams = [];\r\n  }\r\n\r\n  /**\r\n   * Updates the VAD options with new values.\r\n   *\r\n   * @param opts - Partial options object containing the values to update\r\n   * @remarks\r\n   * This method will merge the provided options with existing options and update all active streams.\r\n   * Only the properties specified in opts will be updated, other properties retain their current values.\r\n   */\r\n  updateOptions(opts: Partial<VADOptions>): void {\r\n    this.#opts = { ...this.#opts, ...opts };\r\n    for (const stream of this.#streams) {\r\n      stream.updateOptions(this.#opts);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load and initialize the Silero VAD model.\r\n   *\r\n   * This method loads the ONNX model and prepares it for inference. When options are not provided,\r\n   * sane defaults are used.\r\n   *\r\n   * @remarks\r\n   * This method may take time to load the model into memory.\r\n   * It is recommended to call this method inside your prewarm mechanism.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * export default defineAgent({\r\n   *   prewarm: async (proc: JobProcess) => {\r\n   *     proc.userData.vad = await VAD.load();\r\n   *   },\r\n   *   entry: async (ctx: JobContext) => {\r\n   *     const vad = ctx.proc.userData.vad! as VAD;\r\n   *     // the rest of your agent logic\r\n   *   },\r\n   * });\r\n   * ```\r\n   *\r\n   * @param options -\r\n   * @returns Promise\\<{@link VAD}\\>: An instance of the VAD class ready for streaming.\r\n   */\r\n  static async load(opts: Partial<VADOptions> = {}): Promise<VAD> {\r\n    const mergedOpts: VADOptions = { ...defaultVADOptions, ...opts };\r\n    const session = await newInferenceSession(mergedOpts.forceCPU);\r\n    return new VAD(session, mergedOpts);\r\n  }\r\n\r\n  stream(): VADStream {\r\n    const stream = new VADStream(\r\n      this,\r\n      this.#opts,\r\n      new OnnxModel(this.#session, this.#opts.sampleRate),\r\n    );\r\n    this.#streams.push(stream);\r\n    return stream;\r\n  }\r\n}\r\n\r\nexport class VADStream extends baseStream {\r\n  #opts: VADOptions;\r\n  #model: OnnxModel;\r\n  #inputSampleRate: number;\r\n  #speechBuffer: Int16Array | null;\r\n  #speechBufferMaxReached: boolean;\r\n  #prefixPaddingSamples: number;\r\n  #task: Promise<void>;\r\n  #expFilter = new ExpFilter(0.35);\r\n  #extraInferenceTime = 0;\r\n  #logger = log();\r\n\r\n  constructor(vad: VAD, opts: VADOptions, model: OnnxModel) {\r\n    super(vad);\r\n    this.#opts = opts;\r\n    this.#model = model;\r\n    this.#inputSampleRate = 0;\r\n    this.#speechBuffer = null;\r\n    this.#speechBufferMaxReached = false;\r\n    this.#prefixPaddingSamples = 0;\r\n\r\n    this.#task = new Promise(async () => {\r\n      let inferenceData = new Float32Array(this.#model.windowSizeSamples);\r\n\r\n      // a copy is exposed to the user in END_OF_SPEECH\r\n      let speechBufferIndex = 0;\r\n\r\n      // \"pub\" means public, these values are exposed to the users through events\r\n      let pubSpeaking = false;\r\n      let pubSpeechDuration = 0;\r\n      let pubSilenceDuration = 0;\r\n      let pubCurrentSample = 0;\r\n      let pubTimestamp = 0;\r\n      let speechThresholdDuration = 0;\r\n      let silenceThresholdDuration = 0;\r\n\r\n      let inputFrames = [];\r\n      let inferenceFrames: AudioFrame[] = [];\r\n      let resampler: AudioResampler | null = null;\r\n\r\n      // used to avoid drift when the sampleRate ratio is not an integer\r\n      let inputCopyRemainingFrac = 0.0;\r\n\r\n      for await (const frame of this.input) {\r\n        if (typeof frame === 'symbol') {\r\n          continue; // ignore flush sentinel for now\r\n        }\r\n\r\n        if (!this.#inputSampleRate || !this.#speechBuffer) {\r\n          this.#inputSampleRate = frame.sampleRate;\r\n          this.#prefixPaddingSamples = Math.trunc(\r\n            (this.#opts.prefixPaddingDuration * this.#inputSampleRate) / 1000,\r\n          );\r\n          const bufferSize =\r\n            Math.trunc((this.#opts.maxBufferedSpeech * this.#inputSampleRate) / 1000) +\r\n            this.#prefixPaddingSamples;\r\n          this.#speechBuffer = new Int16Array(bufferSize);\r\n\r\n          if (this.#opts.sampleRate !== this.#inputSampleRate) {\r\n            // resampling needed: the input sample rate isn't the same as the model's\r\n            // sample rate used for inference\r\n            resampler = new AudioResampler(\r\n              this.#inputSampleRate,\r\n              this.#opts.sampleRate,\r\n              1,\r\n              AudioResamplerQuality.QUICK, // VAD doesn't need high quality\r\n            );\r\n          }\r\n        } else if (frame.sampleRate !== this.#inputSampleRate) {\r\n          this.#logger.error('a frame with a different sample rate was already published');\r\n          continue;\r\n        }\r\n\r\n        inputFrames.push(frame);\r\n        if (resampler) {\r\n          inferenceFrames.push(...resampler.push(frame));\r\n        } else {\r\n          inferenceFrames.push(frame);\r\n        }\r\n\r\n        while (true) {\r\n          const startTime = process.hrtime.bigint();\r\n          const availableInferenceSamples = inferenceFrames\r\n            .map((x) => x.samplesPerChannel)\r\n            .reduce((acc, x) => acc + x, 0);\r\n\r\n          if (availableInferenceSamples < this.#model.windowSizeSamples) {\r\n            break; // not enough samples to run inference\r\n          }\r\n\r\n          const inputFrame = mergeFrames(inputFrames);\r\n          const inferenceFrame = mergeFrames(inferenceFrames);\r\n\r\n          // convert data to f32\r\n          inferenceData = Float32Array.from(\r\n            inferenceFrame.data.subarray(0, this.#model.windowSizeSamples),\r\n            (x) => x / 32767,\r\n          );\r\n\r\n          const p = await this.#model\r\n            .run(inferenceData)\r\n            .then((data) => this.#expFilter.apply(1, data));\r\n\r\n          const windowDuration = (this.#model.windowSizeSamples / this.#opts.sampleRate) * 1000;\r\n          pubCurrentSample += this.#model.windowSizeSamples;\r\n          pubTimestamp += windowDuration;\r\n          const resamplingRatio = this.#inputSampleRate / this.#model.sampleRate;\r\n          const toCopy = this.#model.windowSizeSamples * resamplingRatio + inputCopyRemainingFrac;\r\n          const toCopyInt = Math.trunc(toCopy);\r\n          inputCopyRemainingFrac = toCopy - toCopyInt;\r\n\r\n          // copy the inference window to the speech buffer\r\n          const availableSpace = this.#speechBuffer.length - speechBufferIndex;\r\n          const toCopyBuffer = Math.min(this.#model.windowSizeSamples, availableSpace);\r\n          if (toCopyBuffer > 0) {\r\n            this.#speechBuffer.set(inputFrame.data.subarray(0, toCopyBuffer), speechBufferIndex);\r\n            speechBufferIndex += toCopyBuffer;\r\n          } else if (!this.#speechBufferMaxReached) {\r\n            this.#speechBufferMaxReached = true;\r\n            this.#logger.warn(\r\n              'maxBufferedSpeech reached, ignoring further data for the current speech input',\r\n            );\r\n          }\r\n\r\n          const inferenceDuration = Number((process.hrtime.bigint() - startTime) / BigInt(1000000));\r\n          this.#extraInferenceTime = Math.max(\r\n            0,\r\n            this.#extraInferenceTime + inferenceDuration - windowDuration,\r\n          );\r\n          if (this.#extraInferenceTime > SLOW_INFERENCE_THRESHOLD) {\r\n            this.#logger\r\n              .child({ delay: this.#extraInferenceTime })\r\n              .warn('inference is slower than realtime');\r\n          }\r\n\r\n          if (pubSpeaking) {\r\n            pubSpeechDuration += inferenceDuration;\r\n          } else {\r\n            pubSilenceDuration += inferenceDuration;\r\n          }\r\n\r\n          this.queue.put({\r\n            type: VADEventType.INFERENCE_DONE,\r\n            samplesIndex: pubCurrentSample,\r\n            timestamp: pubTimestamp,\r\n            silenceDuration: pubSilenceDuration,\r\n            speechDuration: pubSpeechDuration,\r\n            probability: p,\r\n            inferenceDuration,\r\n            frames: [\r\n              new AudioFrame(\r\n                inputFrame.data.subarray(0, toCopyInt),\r\n                this.#inputSampleRate,\r\n                1,\r\n                toCopyInt,\r\n              ),\r\n            ],\r\n            speaking: pubSpeaking,\r\n            rawAccumulatedSilence: silenceThresholdDuration,\r\n            rawAccumulatedSpeech: speechThresholdDuration,\r\n          });\r\n\r\n          const resetWriteCursor = () => {\r\n            if (!this.#speechBuffer) throw new Error('speechBuffer is empty');\r\n            if (speechBufferIndex <= this.#prefixPaddingSamples) {\r\n              return;\r\n            }\r\n\r\n            const paddingData = this.#speechBuffer.subarray(\r\n              speechBufferIndex - this.#prefixPaddingSamples,\r\n              speechBufferIndex,\r\n            );\r\n            this.#speechBuffer.set(paddingData, 0);\r\n            speechBufferIndex = this.#prefixPaddingSamples;\r\n            this.#speechBufferMaxReached = false;\r\n          };\r\n\r\n          const copySpeechBuffer = (): AudioFrame => {\r\n            if (!this.#speechBuffer) throw new Error('speechBuffer is empty');\r\n            return new AudioFrame(\r\n              this.#speechBuffer.subarray(this.#prefixPaddingSamples, speechBufferIndex),\r\n              this.#inputSampleRate,\r\n              1,\r\n              speechBufferIndex,\r\n            );\r\n          };\r\n\r\n          if (p > this.#opts.activationThreshold) {\r\n            speechThresholdDuration += windowDuration;\r\n            silenceThresholdDuration = 0;\r\n            if (!pubSpeaking && speechThresholdDuration >= this.#opts.minSpeechDuration) {\r\n              pubSpeaking = true;\r\n              pubSilenceDuration = 0;\r\n              pubSpeechDuration = speechThresholdDuration;\r\n\r\n              this.queue.put({\r\n                type: VADEventType.START_OF_SPEECH,\r\n                samplesIndex: pubCurrentSample,\r\n                timestamp: pubTimestamp,\r\n                silenceDuration: pubSilenceDuration,\r\n                speechDuration: pubSpeechDuration,\r\n                probability: p,\r\n                inferenceDuration,\r\n                frames: [copySpeechBuffer()],\r\n                speaking: pubSpeaking,\r\n                rawAccumulatedSilence: 0,\r\n                rawAccumulatedSpeech: 0,\r\n              });\r\n            }\r\n          } else {\r\n            silenceThresholdDuration += windowDuration;\r\n            speechThresholdDuration = 0;\r\n\r\n            if (!pubSpeaking) {\r\n              resetWriteCursor();\r\n            }\r\n\r\n            if (pubSpeaking && silenceThresholdDuration > this.#opts.minSilenceDuration) {\r\n              pubSpeaking = false;\r\n              pubSpeechDuration = 0;\r\n              pubSilenceDuration = silenceThresholdDuration;\r\n\r\n              this.queue.put({\r\n                type: VADEventType.END_OF_SPEECH,\r\n                samplesIndex: pubCurrentSample,\r\n                timestamp: pubTimestamp,\r\n                silenceDuration: pubSilenceDuration,\r\n                speechDuration: pubSpeechDuration,\r\n                probability: p,\r\n                inferenceDuration,\r\n                frames: [copySpeechBuffer()],\r\n                speaking: pubSpeaking,\r\n                rawAccumulatedSilence: 0,\r\n                rawAccumulatedSpeech: 0,\r\n              });\r\n\r\n              resetWriteCursor();\r\n            }\r\n          }\r\n\r\n          inputFrames = [];\r\n          inferenceFrames = [];\r\n\r\n          if (inputFrame.data.length > toCopyInt) {\r\n            const data = inputFrame.data.subarray(toCopyInt);\r\n            inputFrames.push(\r\n              new AudioFrame(data, this.#inputSampleRate, 1, Math.trunc(data.length / 2)),\r\n            );\r\n          }\r\n          if (inferenceFrame.data.length > this.#model.windowSizeSamples) {\r\n            const data = inferenceFrame.data.subarray(this.#model.windowSizeSamples);\r\n            inferenceFrames.push(\r\n              new AudioFrame(data, this.#opts.sampleRate, 1, Math.trunc(data.length / 2)),\r\n            );\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update the VAD options\r\n   *\r\n   * @param opts - Partial options object containing the values to update\r\n   * @remarks\r\n   * This method allows you to update the VAD options after the VAD object has been created\r\n   */\r\n  updateOptions(opts: Partial<VADOptions>) {\r\n    const oldMaxBufferedSpeech = this.#opts.maxBufferedSpeech;\r\n    this.#opts = { ...this.#opts, ...opts };\r\n\r\n    if (this.#inputSampleRate) {\r\n      // Assert speech buffer exists\r\n      if (this.#speechBuffer === null) throw new Error('speechBuffer is null');\r\n\r\n      // Resize speech buffer\r\n      this.#prefixPaddingSamples = Math.trunc(\r\n        (this.#opts.prefixPaddingDuration * this.#inputSampleRate) / 1000,\r\n      );\r\n      const bufferSize =\r\n        Math.trunc((this.#opts.maxBufferedSpeech * this.#inputSampleRate) / 1000) +\r\n        this.#prefixPaddingSamples;\r\n      const resizedBuffer = new Int16Array(bufferSize);\r\n      resizedBuffer.set(\r\n        this.#speechBuffer.subarray(0, Math.min(this.#speechBuffer.length, bufferSize)),\r\n      );\r\n      this.#speechBuffer = resizedBuffer;\r\n\r\n      // Determine if max has been reached\r\n      if (this.#opts.maxBufferedSpeech > oldMaxBufferedSpeech) {\r\n        this.#speechBufferMaxReached = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}