{"version":3,"sources":["../src/onnx_model.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\r\n//\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport { fileURLToPath } from 'node:url';\r\nimport { InferenceSession, Tensor } from 'onnxruntime-node';\r\n\r\nexport type SampleRate = 8000 | 16000;\r\n\r\nexport const newInferenceSession = (forceCPU: boolean) => {\r\n  return InferenceSession.create(fileURLToPath(new URL('silero_vad.onnx', import.meta.url).href), {\r\n    interOpNumThreads: 1,\r\n    intraOpNumThreads: 1,\r\n    executionMode: 'sequential',\r\n    executionProviders: forceCPU ? [{ name: 'cpu' }] : undefined,\r\n  });\r\n};\r\n\r\nexport class OnnxModel {\r\n  #session: InferenceSession;\r\n  #sampleRate: number;\r\n  #windowSizeSamples: number;\r\n  #contextSize: number;\r\n  #sampleRateNd: BigInt64Array;\r\n  #context: Float32Array;\r\n  // #state: Float32Array;\r\n  #rnnState: Float32Array;\r\n  #inputBuffer: Float32Array;\r\n\r\n  constructor(session: InferenceSession, sampleRate: SampleRate) {\r\n    this.#session = session;\r\n    this.#sampleRate = sampleRate;\r\n\r\n    switch (sampleRate) {\r\n      case 8000:\r\n        this.#windowSizeSamples = 256;\r\n        this.#contextSize = 32;\r\n        break;\r\n      case 16000:\r\n        this.#windowSizeSamples = 512;\r\n        this.#contextSize = 64;\r\n        break;\r\n    }\r\n\r\n    this.#sampleRateNd = BigInt64Array.from([BigInt(sampleRate)]);\r\n    this.#context = new Float32Array(this.#contextSize);\r\n    this.#rnnState = new Float32Array(2 * 1 * 128);\r\n    this.#inputBuffer = new Float32Array(this.#contextSize + this.#windowSizeSamples);\r\n  }\r\n\r\n  get sampleRate(): number {\r\n    return this.#sampleRate;\r\n  }\r\n\r\n  get windowSizeSamples(): number {\r\n    return this.#windowSizeSamples;\r\n  }\r\n\r\n  get contextSize(): number {\r\n    return this.#contextSize;\r\n  }\r\n\r\n  async run(x: Float32Array): Promise<number> {\r\n    this.#inputBuffer.set(this.#context, 0);\r\n    this.#inputBuffer.set(x, this.#contextSize);\r\n\r\n    return await this.#session\r\n      .run({\r\n        input: new Tensor('float32', this.#inputBuffer, [\r\n          1,\r\n          this.#contextSize + this.#windowSizeSamples,\r\n        ]),\r\n        state: new Tensor('float32', this.#rnnState, [2, 1, 128]),\r\n        sr: new Tensor('int64', this.#sampleRateNd),\r\n      })\r\n      .then((result) => {\r\n        // this.#state = result.output.data as Float32Array,\r\n        this.#context = this.#inputBuffer.subarray(0, this.#contextSize);\r\n        return (result.output!.data as Float32Array).at(0)!;\r\n      });\r\n  }\r\n}\r\n"],"mappings":"AAGA,SAAS,qBAAqB;AAC9B,SAAS,kBAAkB,cAAc;AAIlC,MAAM,sBAAsB,CAAC,aAAsB;AACxD,SAAO,iBAAiB,OAAO,cAAc,IAAI,IAAI,mBAAmB,YAAY,GAAG,EAAE,IAAI,GAAG;AAAA,IAC9F,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,eAAe;AAAA,IACf,oBAAoB,WAAW,CAAC,EAAE,MAAM,MAAM,CAAC,IAAI;AAAA,EACrD,CAAC;AACH;AAEO,MAAM,UAAU;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA,YAAY,SAA2B,YAAwB;AAC7D,SAAK,WAAW;AAChB,SAAK,cAAc;AAEnB,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,aAAK,qBAAqB;AAC1B,aAAK,eAAe;AACpB;AAAA,MACF,KAAK;AACH,aAAK,qBAAqB;AAC1B,aAAK,eAAe;AACpB;AAAA,IACJ;AAEA,SAAK,gBAAgB,cAAc,KAAK,CAAC,OAAO,UAAU,CAAC,CAAC;AAC5D,SAAK,WAAW,IAAI,aAAa,KAAK,YAAY;AAClD,SAAK,YAAY,IAAI,aAAa,IAAI,IAAI,GAAG;AAC7C,SAAK,eAAe,IAAI,aAAa,KAAK,eAAe,KAAK,kBAAkB;AAAA,EAClF;AAAA,EAEA,IAAI,aAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,oBAA4B;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,cAAsB;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,IAAI,GAAkC;AAC1C,SAAK,aAAa,IAAI,KAAK,UAAU,CAAC;AACtC,SAAK,aAAa,IAAI,GAAG,KAAK,YAAY;AAE1C,WAAO,MAAM,KAAK,SACf,IAAI;AAAA,MACH,OAAO,IAAI,OAAO,WAAW,KAAK,cAAc;AAAA,QAC9C;AAAA,QACA,KAAK,eAAe,KAAK;AAAA,MAC3B,CAAC;AAAA,MACD,OAAO,IAAI,OAAO,WAAW,KAAK,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,MACxD,IAAI,IAAI,OAAO,SAAS,KAAK,aAAa;AAAA,IAC5C,CAAC,EACA,KAAK,CAAC,WAAW;AAEhB,WAAK,WAAW,KAAK,aAAa,SAAS,GAAG,KAAK,YAAY;AAC/D,aAAQ,OAAO,OAAQ,KAAsB,GAAG,CAAC;AAAA,IACnD,CAAC;AAAA,EACL;AACF;","names":[]}